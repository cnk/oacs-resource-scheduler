ad_library {

    A set of procs that aid the developer in generating stub function for tcl libraries and 
    common www pages.

    @creation-date 3/14/2005
    @cvs-id $Id: prototype-procs.tcl,v 1.3 2005/09/20 23:31:22 jwang1 Exp $
}

namespace eval ctrl_procs::prototype {}

ad_proc -public ctrl_procs::prototype::generate_get {
    {-file_path:required}
    {-complete_proc_name:required}
    {-table:required}
    {-cols_to_select:required}
    {-id_name:required}
    {-where_clause:required}
    {-overwrite_p:required 1}
} {
    Generate a select get method that will read from a table and
    will upvar the results into an array. This proc also handles date formatting if you pass in a pair in the cols_to_select list.
    
    @param file_path The absolute file path to the tcl library to generate the proc in. For example, /web/ucla/packages/ctrl-procs/tcl/test-procs .
    @param complete_proc_name The complete name of the proc, including the name space. For example,  ctrl_procs::prototype::generate_get.
    @param table The name of the table to select from.
    @param id_name the name of the id parameter in the proc. For example, object_id or user_id, if selecting from the acs_objects table
    or user table, respectively.
    
    @param cols_to_select a list of the column names to select and store in the array. If the item is a pair, then we'll assume it's a date
                          where the first item is the name of the date and the second item is the call to to_char. For example, an
                          item in cols_to_select list might be  {start_date, to_char(:start_date, 'yyyy mm dd'}.

    @param where_clause the where clause of the select statement. For example, object_id=:object_id
    @param overwrite_p If set to true, it will overwrite an existing proc.

    <pre>
    <code>
    Example for your convenience:
    
    ctrl_procs::prototype::generate_get 
	-file_path "/web/acs46-dev/www/test-procs" 
	-complete_proc_name "openacs::test::get" 
	-table "users" 
	-cols_to_select [list "user_id" "first_names"  "last_name"] 
	-id_name "user_id" 
	-where_clause "user_id=:user_id" 
	-overwrite_p 1
    
    will generate procs in the following 2 files:
    
    
    (1) /web/acs46-dev/www/test-procs.tcl:
    ###START: This proc was generated by the ctrl prototype procs -- openacs::test::get
    ad_proc -public openacs::test::get {
	{-array:required} 
	{-user_id:required}
    } {
	Select something from the database
    } {
	upvar $array local_array
	db_0or1row get {} -column_array local_array 
    }
    ###END: This proc was generated by the ctrl prototype procs -- openacs::test::get
    
    (2) /web/acs46-dev/www/test-procs.xql:
    
    < !-- START openacs::test::get.get -- >
    < fullquery name= openacs::test::get.get >
      < querytext >
       select user_id,first_names,last_name
       from users
       where user_id=:user_id
      < /querytext >
    < /fullquery >
    < !-- END openacs::test::get.get -- >

    </code>
    </pre>
 
} {
    set markers [ctrl_procs::prototype::generate_tcl_markers -name $complete_proc_name]
    set tcl_start_marker [lindex $markers 0]
    set tcl_end_marker [lindex $markers 1]
    set markers [ctrl_procs::prototype::generate_xql_markers -name "${complete_proc_name}.get"]
    set xql_start_marker [lindex $markers 0]
    set xql_end_marker [lindex $markers 1]
    
    set selected_fields ""
    set col_length [llength $cols_to_select]
    set count 1
    foreach item $cols_to_select {
	if {$count == $col_length} {
	      append selected_fields "[lindex $item 0]"
	} else {
	    append selected_fields "[lindex $item 0] ,"
	}
	incr count
    }

    set proc_contents "
$tcl_start_marker
ad_proc -public $complete_proc_name {
    {-column_array:required} 
    {-${id_name}:required}
} {
    Select $selected_fields from $table

    @param column_array The array that we upvar information into
    @param $id_name
    
} {
    upvar \$column_array local_array
    db_0or1row get {} -column_array local_array 
}
$tcl_end_marker
"	

  ctrl_procs::prototype::write_file \
	  -proc_name $complete_proc_name \
	  -file_path $file_path \
	  -contents $proc_contents \
	  -overwrite_p $overwrite_p \
	  -file_type "tcl"
 

  set select_cols ""
  foreach col $cols_to_select {

      #check to see if this is a date and format it, if it is
      if {[llength $col] == 2} {
	  set col "[lindex $col 1] as [lindex $col 0]"
      }

      if {[empty_string_p $select_cols]} {
	  append select_cols "$col"
      } else {
	  append select_cols ",$col"
      }
  }


  set xql_contents "$xql_start_marker
<fullquery name=\"${complete_proc_name}.get\">
  <querytext>
   select $select_cols
   from $table
   where $where_clause
  </querytext>
</fullquery>
$xql_end_marker
"

    ctrl_procs::prototype::write_file \
	  -proc_name ${complete_proc_name}.get \
	  -file_path $file_path \
	  -contents $xql_contents \
	  -overwrite_p $overwrite_p \
	  -file_type "xql"

    return [list $proc_contents $xql_contents]
}


ad_proc -public ctrl_procs::prototype::generate_delete {
    {-file_path:required}
    {-complete_proc_name:required}
    {-id_name:required}
    {-table:required}
    {-where_clause:required}
    {-return_error_msg:required ""}
    {-overwrite_p:required 1}
} {
    Generate a delete function for deleting from a table (not an acs_object delete)
    
    @param file_path The absolute file path to the tcl library to generate the proc in. For example, /web/ucla/packages/ctrl-procs/tcl/test-procs .
    @param complete_proc_name The complete name of the proc, including the name space. For example,  ctrl_procs::prototype::generate_get.
    @param table The name of the table to delete from.
    @param id_name the name of the argument for the id in the generated proc

    @param where_clause the where clause of the select statement. For example, object_id=:object_id
    @param return_error_msg The error msg to return if there's a problem.
    @param overwrite_p If set to true, it will overwrite an existing proc.

    <pre>
    <code>
    Example for your convenience:
    
    ctrl_procs::prototype::generate_delete 
	-file_path "/web/acs46-dev/www/test-procs" 
	-complete_proc_name "openacs::test::delete" 
	-table "users" 
	-id_name "user_id" 
	-where_clause "user_id=:user_id" 
	-return_error_msg "Problem deleting user." 
	-overwrite_p 1
    
    will generate procs in the following 2 files:
    
    
    (1) /web/acs46-dev/www/test-procs.tcl:
    ###START: This proc was generated by the ctrl prototype procs -- openacs::test::delete
    ad_proc -public openacs::test::delete {
	{-user_id:required}
    } {
	Delete an item from users
    } {
	set error_p 0
	db_transaction {
	    db_dml delete {}
	} on_error {
	    set error_p 1
	}
    
	if {$error_p} {
	    ad_return_complaint 1 "Problem deleting user. $errmsg "
	    ad_script_abort
	}
    }
    ###END: This proc was generated by the ctrl prototype procs -- openacs::test::delete

    (2) /web/acs46-dev/www/test-procs-oracle.xql:
     
    < !-- START openacs::test::delete.delete -- >
      < fullquery name= openacs::test::delete.delete >
       < querytext >
         delete from users where user_id=:user_id
       < /querytext >
      < /fullquery >
    < !-- END openacs::test::delete.delete -- > 
    </code>
    </pre>
    

} {
    set markers [ctrl_procs::prototype::generate_tcl_markers -name $complete_proc_name]
    set tcl_start_marker [lindex $markers 0]
    set tcl_end_marker [lindex $markers 1]
    set markers [ctrl_procs::prototype::generate_xql_markers -name "${complete_proc_name}.delete"]
    set xql_start_marker [lindex $markers 0]
    set xql_end_marker [lindex $markers 1]

    if {[empty_string_p $return_error_msg]} {
	set return_error_msg "There was a problem deleting the item -- <br>"
    }
    
    set proc_contents "
$tcl_start_marker
ad_proc -public $complete_proc_name {
    {-${id_name}:required}
} {
    Delete an item from $table

    @param $id_name

} {
    set error_p 0
    db_transaction {
	db_dml delete {}
    } on_error {
	set error_p 1
    }
    
    if {\$error_p} {
	ad_return_complaint 1 \"$return_error_msg \$errmsg \"
 	ad_script_abort
    }
}
$tcl_end_marker"	

     ctrl_procs::prototype::write_file \
	  -proc_name $complete_proc_name \
	  -file_path $file_path \
	  -contents $proc_contents \
	  -overwrite_p $overwrite_p \
	  -file_type "tcl"
 
     set xql_contents "$xql_start_marker
<fullquery name=\"${complete_proc_name}.delete\">
  <querytext>
   delete from $table where $where_clause
  </querytext>
</fullquery>
$xql_end_marker"

    ctrl_procs::prototype::write_file \
	    -proc_name ${complete_proc_name}.delete \
	  -file_path "${file_path}-oracle" \
	  -contents $xql_contents \
	  -overwrite_p $overwrite_p \
	  -file_type "xql"

    return [list $proc_contents $xql_contents]
}

ad_proc -public ctrl_procs::prototype::generate_remove {
    {-file_path:required}
    {-complete_proc_name:required}
    {-package_function:required}
    {-id_name:required}
    {-return_error_msg:required ""}
    {-overwrite_p:required 1}
} {
    Generate a remove function for removing an object
    
    @param file_path The absolute file path to the tcl library to generate the proc in. For example, /web/ucla/packages/ctrl-procs/tcl/test-procs .
    @param complete_proc_name The complete name of the proc, including the name space. For example,  ctrl_procs::prototype::generate_get.
    @param package_function the name of the package function in the format of package_key.fuction_name (ie: acs_object.delete)
    @param id_name the name of the argument for the id in the generated proc
    @param return_error_msg The error msg to return if there's a problem.
    @param overwrite_p If set to true, it will overwrite an existing proc.

    <pre>
    <code>
    Example for your convenience:

    ctrl_procs::prototype::generate_remove 
	    -file_path "/web/acs46-dev/www/test-procs" 
	    -package_function "test_package.remove" 
	    -complete_proc_name "openacs::test::remove" 
	    -id_name "page_id" 
	    -return_error_msg "Problem removing." 
	    -overwrite_p 1
    
    will generate procs in the following 2 files:
    
    
    (1) /web/acs46-dev/www/test-procs.tcl:
    ###START: This proc was generated by the ctrl prototype procs -- openacs::test::remove
    ad_proc -public openacs::test::remove {
	{-page_id:required}
    } {
	Remove an acs_object by calling the associated pl/sql function
    } {
	set error_p 0
	db_transaction {
	    db_exec_plsql remove {} 
	} on_error {
	    set error_p 1
	}
	
	if {$error_p} {
	    ad_return_complaint 1 "Problem removing. $errmsg "
	    ad_script_abort
	}
    }
    ###END: This proc was generated by the ctrl prototype procs -- openacs::test::remove
   
    (2) /web/acs46-dev/www/test-procs-oracle.xql:
    < !-- START openacs::test::remove.remove -- >
      < fullquery name= openacs::test::remove.remove >
        < querytext>
         begin
	   test_package.remove (
              page_id =>	:page_id
	   );
         end;		
        < /querytext>
       < /fullquery>
    < !-- END openacs::test::remove.remove -->

    </code>
    </pre>
} {
    set markers [ctrl_procs::prototype::generate_tcl_markers -name $complete_proc_name]
    set tcl_start_marker [lindex $markers 0]
    set tcl_end_marker [lindex $markers 1]
    set markers [ctrl_procs::prototype::generate_xql_markers -name "${complete_proc_name}.remove"]
    set xql_start_marker [lindex $markers 0]
    set xql_end_marker [lindex $markers 1]

    if {[empty_string_p $return_error_msg]} {
	set return_error_msg "There was a problem removing the object -- <br>"
    }
    
    set proc_contents "
$tcl_start_marker
ad_proc -public $complete_proc_name {
    {-${id_name}:required}
} {
    Remove an acs_object by calling the associated pl/sql function

    @param $id_name
} {
    set error_p 0
    db_transaction {
	db_exec_plsql remove {} 
    } on_error {
	set error_p 1
    }
    
    if {\$error_p} {
	ad_return_complaint 1 \"$return_error_msg \$errmsg \"
 	ad_script_abort
    }
}
$tcl_end_marker"	

     ctrl_procs::prototype::write_file \
	  -proc_name $complete_proc_name \
	  -file_path $file_path \
	  -contents $proc_contents \
	  -overwrite_p $overwrite_p \
	  -file_type "tcl"
 
     set xql_contents "
$xql_start_marker
<fullquery name=\"${complete_proc_name}.remove\">
  <querytext>
   begin
	$package_function (
           $id_name =>	:${id_name}
	);
   end;		
  </querytext>
</fullquery>
$xql_end_marker
"

    ctrl_procs::prototype::write_file \
	    -proc_name ${complete_proc_name}.remove \
	    -file_path "${file_path}-oracle" \
	    -contents $xql_contents \
	    -overwrite_p $overwrite_p \
	    -file_type "xql"

    return [list $proc_contents $xql_contents]
}

ad_proc -public ctrl_procs::prototype::generate_insert {
    {-file_path:required}
    {-complete_proc_name:required}
    {-table:required}
    {-return_error_msg:required ""}
    {-key_sequence_name ""}
    {-primary_key_col_name ""}
    {-values:required}
    {-overwrite_p:required 1}
} {
    Generate a insert function for inserting into a table (not an acs_object delete)
    
    @param file_path The absolute file path to the tcl library to generate the proc in. For example, /web/ucla/packages/ctrl-procs/tcl/test-procs .
    @param complete_proc_name The complete name of the proc, including the name space. For example,  ctrl_procs::prototype::generate_get.
    @param table The name of the table to insert into.
    @param key_sequence_name The sequence name of the sequence to get the next value of.
    @param primary_key_col_name this should be the name of the primary key on the table and the value that is returned from the insert proc.  It should
    also be an item in the values list that you pass in.
    @param values A list of sublists where each sublists contains the column name to insert and a default value,
     the default value will be a string format with the following special key words : user_id, sysdate, sequence, to_date, or none. You may also pass in ":required" 
     as part of the value name to indicate that the value is required. (ie: my_arg:required)


    @param return_error_msg The error msg to return if there's a problem.
    @param overwrite_p If set to true, it will overwrite an existing proc.

    <pre>
    <code>
    Example for your convenience:

    ctrl_procs::prototype::generate_insert 
	-file_path "/web/acs46-dev/www/test-procs" 
	-complete_proc_name "openacs::test::insert" 
	-table "users" 
	-return_error_msg "Problem inserting user." 
	-values [list {first_names none} {user_id user_id} {test_date sysdate} {test_string hello} {date2 sysdate}] \
	-overwrite_p 1
  
    
    will generate procs in the following 2 files:
    
    (1) /web/acs46-dev/www/test-procs.tcl:
    

    ###START: This proc was generated by the ctrl prototype procs -- openacs::test::insert
    ad_proc -public openacs::test::insert {
	{-first_names:required} 
	{-user_id:required ""} 
	{-test_date:required ""} 
	{-test_string:required "hello"} 
	{-date2:required ""} 
    } {
	Insert a row into users
    } {
	if {[empty_string_p $user_id] } { set user_id [ad_conn user_id]}
	if {[empty_string_p $test_date] } { set test_date [clock format [clock seconds] -format "%D %T" ]}
	if {[empty_string_p $date2] } { set date2 [clock format [clock seconds] -format "%D %T" ]}
	
	set error_p 0
	db_transaction {
	    db_dml insert {}
	} on_error {
	    set error_p 1
	}
	
	if {$error_p} {
	    ad_return_complaint 1 "Problem inserting user. $errmsg "
	    ad_script_abort
	}
    }
    ###END: This proc was generated by the ctrl prototype procs -- openacs::test::insert


    (2) /web/acs46-dev/www/test-procs-oracle.xql:
    < !-- START openacs::test::insert.insert -->
      < fullquery name= openacs::test::insert.insert>
       < querytext>
        insert into users ( first_names ,
                            user_id ,
                            test_date ,
                            test_string ,
                            date2 
                 ) values (:first_names ,
                           :user_id ,
                           to_date(:test_date, 'mm/dd/yy HH24:MI:SS' ) ,
                           :test_string ,
                           to_date(:date2, 'mm/dd/yy HH24:MI:SS' ) 
                 ) 
         < /querytext>
       < /fullquery>
     < !-- END openacs::test::insert.insert -->

    </code>
    </pre>
} {
    set markers [ctrl_procs::prototype::generate_tcl_markers -name $complete_proc_name]
    set tcl_start_marker [lindex $markers 0]
    set tcl_end_marker [lindex $markers 1]
    set markers [ctrl_procs::prototype::generate_xql_markers -name "${complete_proc_name}.insert"]
    set xql_start_marker [lindex $markers 0]
    set xql_end_marker [lindex $markers 1]

    if {[empty_string_p $return_error_msg]} {
	set return_error_msg "There was a problem inserting the item -- <br>"
    }

    #parse the values
    set parsed_values [ctrl_procs::prototype::parse_arg_values -values_list $values -file_type "tcl" -key_sequence_name $key_sequence_name]


    set args [lindex $parsed_values 0]
    set defaults_code [lindex $parsed_values 1]
    set param_string ""

    foreach item $values {
	append param_string "\t@param [lindex $item 0]\n"
     }

     if {![empty_string_p $primary_key_col_name]} {
	 set return_info "return \$${primary_key_col_name}"
     } else {
	 set return_info ""
     }


    set proc_contents "
$tcl_start_marker
ad_proc -public $complete_proc_name {
$args\
} {
    Insert a row into $table

$param_string
} {
$defaults_code

    set error_p 0
    db_transaction {
	db_dml insert {}
    } on_error {
	set error_p 1
    }
    
    if {\$error_p} {
	ad_return_complaint 1 \"$return_error_msg \$errmsg \"
 	ad_script_abort
    }

    $return_info
}
$tcl_end_marker
"	

     ctrl_procs::prototype::write_file \
	  -proc_name $complete_proc_name \
	  -file_path "${file_path}" \
	  -contents $proc_contents \
	  -overwrite_p $overwrite_p \
	  -file_type "tcl"
 

    #parse the values
    set parsed_values [ctrl_procs::prototype::parse_arg_values -values_list $values -file_type "xql"  -key_sequence_name $key_sequence_name]
    set values [lindex $parsed_values 0]
    set bind_values [lindex $parsed_values 1]

     set xql_contents "
$xql_start_marker
<fullquery name=\"${complete_proc_name}.insert\">
  <querytext>
   insert into $table $values $bind_values 
  </querytext>
</fullquery>
$xql_end_marker
"

    ctrl_procs::prototype::write_file \
	    -proc_name ${complete_proc_name}.insert \
	  -file_path "${file_path}-oracle" \
	  -contents $xql_contents \
	  -overwrite_p $overwrite_p \
	  -file_type "xql"


    return [list $proc_contents $xql_contents]
}





ad_proc -public ctrl_procs::prototype::generate_new {
    {-file_path:required}
    {-complete_proc_name:required}
    {-return_error_msg ""}
    {-overwrite_p:required 1}
} {
    Generate a function for creating new objects
    
    @param file_path The absolute file path to the tcl library to generate the proc in. For example, /web/ucla/packages/ctrl-procs/tcl/test-procs .
    @param complete_proc_name The complete name of the proc, including the name space. For example,  ctrl_procs::prototype::generate_get.
    @param return_error_msg The error msg to return if there's a problem.
    @param overwrite_p If set to true, it will overwrite an existing proc.
    
    <pre>
    <code>
    Example for your convenience:

    ctrl_procs::prototype::generate_new 
	-file_path "/web/acs46-dev/www/test-procs" 
	-complete_proc_name "openacs::test::new" 
	-overwrite_p 1

    
    will generate procs in the following 1 file:
    
    
    (1) /web/acs46-dev/www/test-procs.tcl:
   
    ###START: This proc was generated by the ctrl prototype procs -- openacs::test::new
    ad_proc -public openacs::test::new {
	{-var_list ""}
	{-object_type:required}
    } {
	Creates a new acs_object
    } {
	set error_p 0
	db_transaction {
	    set id [package_instantiate_object \
		    -var_list $var_list \
		    $object_type ]
	} on_error {
	    set error_p 1
	}
	
	if {$error_p} {
	    ad_return_complaint 1 "There was a problem removing the object -- <br> $errmsg "
	    ad_script_abort
	}
	return $id
    }
    ###END: This proc was generated by the ctrl prototype procs -- openacs::test::new
    </code>
    </pre>

} {
    set markers [ctrl_procs::prototype::generate_tcl_markers -name $complete_proc_name]
    set tcl_start_marker [lindex $markers 0]
    set tcl_end_marker [lindex $markers 1]
    set markers [ctrl_procs::prototype::generate_xql_markers -name "${complete_proc_name}.new"]
    set xql_start_marker [lindex $markers 0]
    set xql_end_marker [lindex $markers 1]

    if {[empty_string_p $return_error_msg]} {
	set return_error_msg "There was a problem removing the object -- <br>"
    }
    
    set proc_contents "
$tcl_start_marker
ad_proc -public $complete_proc_name {
    {-var_list \"\"}
    {-object_type:required}
} {
    Creates a new acs_object

    @param var_list a list of key value pairs to be supplied to the pl/sql call
    @param object_type the type of object you are creating

} {
    set error_p 0
    db_transaction {
	set id \[package_instantiate_object \\
		-var_list \$var_list \\
		\$object_type \]
    } on_error {
	set error_p 1
    }
    
    if {\$error_p} {
	ad_return_complaint 1 \"$return_error_msg \$errmsg \"
 	ad_script_abort
    }
    return \$id
}
$tcl_end_marker"	

   ctrl_procs::prototype::write_file \
	   -proc_name $complete_proc_name \
	   -file_path $file_path \
	   -contents $proc_contents \
	   -overwrite_p $overwrite_p \
	   -file_type "tcl"

     return [list $proc_contents ""]
}

ad_proc -public ctrl_procs::prototype::generate_update {
    {-file_path:required}
    {-complete_proc_name:required}
    {-table:required}
    {-return_error_msg:required ""}
    {-values:required}
    {-where_clause:required}
    {-overwrite_p:required 1}
    {-object_p:required 0}
    {-id_name:required}
} {
    Generate an update proc for updating a table or acs_object
    
    @param file_path The absolute file path to the tcl library to generate the proc in. For example, /web/ucla/packages/ctrl-procs/tcl/test-procs .
    @param complete_proc_name The complete name of the proc, including the name space. For example,  ctrl_procs::prototype::generate_get.
    @param table The name of the table to insert into.
    @param return_error_msg The error msg to return if there's a problem.

    @param values A list of the names of values to update. To handle date types, pass in a pair where the first item is the column name and 
                  the second item is the string 'to_date'. For example, {start_date to_date}.  You may also pass in ":required" as part of the value name to indicate
                  that the value is required. (ie: my_arg:required)

    @param where_clause the where clause of the select statement. For example, object_id=:object_id
    @param overwrite_p If set to true, it will overwrite an existing proc.
    @param object_p 1 if this is an acs_object, 0 otherwise. If it's an acs_object, we'll update the modified information in acs_objects table.
    @param id_name the column name of the primary key of this table

} {
    set markers [ctrl_procs::prototype::generate_tcl_markers -name $complete_proc_name]
    set tcl_start_marker [lindex $markers 0]
    set tcl_end_marker [lindex $markers 1]
    set markers [ctrl_procs::prototype::generate_xql_markers -name "${complete_proc_name}.update"]
    set xql_start_marker [lindex $markers 0]
    set xql_end_marker [lindex $markers 1]

    if {[empty_string_p $return_error_msg]} {
	set return_error_msg "There was a problem updating the item -- <br>"
    }
    if {$object_p} {
	set update_object "ctrl_procs::acs_object::update_object -object_id \$$id_name"
    } else {
	set update_object ""
    }

    #convert the values list into a list that can be passed to the parse_arg_values function
    set new_values [list [list $id_name "none"]]
    set param_string ""
    foreach item $values {
	if {[llength $item] == 1} {
	    lappend new_values [list $item "none"]
	    append param_string "\t@param [lindex $item 0]\n"
	} else {
	    lappend new_values $item
	    append param_string "\t@param $item\n"
	}
    }
    set old_values $values
    set values $new_values

    #parse the values for the arguments
    set parsed_values [ctrl_procs::prototype::parse_arg_values -values_list $values -file_type "tcl" -proc_type "update"]
    set proc_arg_check_code ""

    #parse the values for the tcl body
    foreach value_list $old_values {
	set value_name [lindex $value_list 0]
	set value_type [lindex $value_list 1]
	if {[string equal $value_type "to_date"]} {
	    set bind_char "$"
	} else {
	    set bind_char ":"
	}
	regexp {(.):required} $value_name match value_name
	append proc_arg_check_code "\n\tif {\[info exists $value_name\]} {lappend update_list \" $value_name=${bind_char}$value_name \"}\n"
    }
    
    
    set args [lindex $parsed_values 0]
    
    set proc_contents "
$tcl_start_marker
ad_proc -public $complete_proc_name {
$args\
} {
    Update a row in $table
    
    $param_string
} {
    set update_list {}

    $proc_arg_check_code

    set error_p 0
    db_transaction {
	$update_object
	if {\[llength \$update_list\] != 0} {
	    set update_string \[join \$update_list \",\"\]
	    db_dml update {}
	}
    } on_error {
	set error_p 1
    }
    
    if {\$error_p} {
	ad_return_complaint 1 \"$return_error_msg \$errmsg \"
 	ad_script_abort
    }
}
$tcl_end_marker
"	

     ctrl_procs::prototype::write_file \
	  -proc_name $complete_proc_name \
	  -file_path "${file_path}" \
	  -contents $proc_contents \
	  -overwrite_p $overwrite_p \
	  -file_type "tcl"
 

    #parse the values
    #set parsed_values [ctrl_procs::prototype::parse_arg_values -values_list $values -file_type "xql" -proc_type "update"]
    #set values [lindex $parsed_values 0]

     set xql_contents "
$xql_start_marker
<fullquery name=\"${complete_proc_name}.update\">
  <querytext>
   update $table set \$update_string where $where_clause
  </querytext>
</fullquery>
$xql_end_marker
"
     ctrl_procs::prototype::write_file \
	     -proc_name ${complete_proc_name}.update \
	     -file_path "${file_path}-oracle" \
	     -contents $xql_contents \
	     -overwrite_p $overwrite_p \
	     -file_type "xql"

      return [list $proc_contents $xql_contents]
}

################
# Helper Procs #
################

ad_proc -private ctrl_procs::prototype::generate_tcl_markers {
    {-name:required}
} {
    Generate a unique start and end marker that denotes a generated proc.
    
    @returns a list of two items where the first item is the start marker and the second item is an end marker.
} {
    set start_marker "###START: This proc was generated by the ctrl prototype procs -- $name"
    set end_marker "###END: This proc was generated by the ctrl prototype procs -- $name"
    return [list $start_marker $end_marker]
}

ad_proc -private ctrl_procs::prototype::generate_xql_markers {
    {-name:required}
} {
    Generate a unique start and end marker that denotes a generated xql call.
    
    @returns a list of two items where the first item is the start marker and the second item is an end marker.
} {
    set start_marker "<!-- START ${name} -->"
    set end_marker "<!-- END ${name} -->"
    return [list $start_marker $end_marker]
}

ad_proc -private ctrl_procs::prototype::write_file {
    {-proc_name:required}
    {-file_path:required}
    {-contents:required}
    {-overwrite_p:required 0}
    {-file_type:required}
} {
    Either write the contents to a new file or append to the file if it doesn't exist. You may choose to overwrite an existing proc.
    
    @param file_path The absolute file path to the tcl library to generate the proc in. For example, /web/ucla/packages/ctrl-procs/tcl/test-procs .
    @param proc_name The complete name of the proc, including the name space. For example,  ctrl_procs::prototype::generate_get.
    @param contents the contents to write out
    @param overwrite_p If set to true, it will overwrite an existing proc.
    @param file_type What type of file is this xql, tcl, adp, vuh ?
    
    @returns 1 if success and 0 if failed
} {

    append file_path ".$file_type"


    set file_list [glob -nocomplain -- $file_path]
    if {[llength $file_list] == 0} {
	set file_exists_p 0
    } else {
	set file_exists_p 1
    }
    
    if {$file_exists_p} {
	#read in the current file as a string
	set old_contents [template::util::read_file \
		$file_path]

	#Make a backup of the old file by creating a writing into a backup director
	regexp {(.*)/(.*)} $file_path match directory file
	
	template::util::write_file "$directory/backup/${file}.bak"  $old_contents

	#find the begining and end index of this proc 
	if {[string equal $file_type "xql"]} {
	    set markers [ctrl_procs::prototype::generate_xql_markers -name $proc_name]
	    set start_marker [lindex $markers 0]
	    set end_marker [lindex $markers 1]
	} elseif {[string equal $file_type "tcl"]} {
	    set markers [ctrl_procs::prototype::generate_tcl_markers -name $proc_name]
	    set start_marker [lindex $markers 0]
	    set end_marker [lindex $markers 1]
	} else {
	    ad_return_complaint 1 "We don't know how to process overwriting files of type $file_type. \
		    But you can update ctrl_procs::prototype::write_file proc to handle this type!"
	    ad_script_abort
	}
	    
	#find the indices of the start and end markers. These are the indices to write the file to.
	set found_start_p [regexp -indices -- $start_marker $old_contents start_indices]
	set found_end_p [regexp -indices -all  -- $end_marker $old_contents end_indices more]
	

	if {!$found_start_p || !$found_end_p} {
	    #if we couldn't find the start and end marker, assume it's a new proc and append it to the end.
	    
	    #remove the footer from the file (xql only at the moment). We'll add the footer back later
	    set footer [ctrl_procs::prototype::generate_footer \
		    -file_type $file_type]
	    
	    set old_contents [string map [list $footer ""] $old_contents]
	    #just append to the end of the file 
	    append old_contents  $contents [string trim $footer]
	    
	} else {
	    if {$overwrite_p} {
		#re-write the old proc
		set start_index [lindex $start_indices 0]
		set end_index [lindex $end_indices 1]
		set old_contents [string replace $old_contents $start_index $end_index [string trim $contents]]
	    } else {
		#here, we've found an existing proc but specified not to overwrite it. We'll have to complain to the user 
		ad_return_complaint 1 "We found $proc_name, but you specified that you do not want to overwrite this proc. If you want to overwrite the proc, set overwrite_p to true."
		ad_script_abort
	    }
	}

	#write it out
	template::util::write_file $file_path [string trim $old_contents]
	
    } else {
	#if the file doesn't exist yet, generate the approriate headers/footers and write out the file
	set header [ctrl_procs::prototype::generate_header \
		-file_type $file_type \
		-proc_name $proc_name]
	
	set footer [ctrl_procs::prototype::generate_footer \
		-file_type $file_type]
	
	template::util::write_file $file_path "$header \n $contents \n $footer"

    }
}

ad_proc -private ctrl_procs::prototype::generate_header {
    {-file_type:required}
    {-proc_name:required}
} {
    Generate a file header for a particular file like an ad_library header or an xql header
    
    @param file_type What type of file is this xql, tcl, adp, vuh ?
    
} {
    set sysdate [clock format [clock seconds] -format %D]
    if {[string equal $file_type "tcl"]} {
	#generate an ad_library header and a namespace
	set namespace_index [string last  "::" $proc_name]
	set namespace [string replace $proc_name $namespace_index [string length $proc_name]]
	
	if {![empty_string_p $namespace]} {
	    set namespace_text "namespace eval $namespace {}"
	} else {
	    set namespace_text ""
	}
	
	return "ad_library { \n \
		This library was automatically generated.\n\
		@creation-date $sysdate \n\
		@cvs_id \$id\$\n\
	    }\n\
	    $namespace_text	
	"
	
    } elseif {[string equal $file_type "xql"]} {
	return "<?xml version=1.0?>\n \
		<queryset>
	"
    } else {
	#other files don't require headers (yet).
	return ""
    }
}

ad_proc -private ctrl_procs::prototype::generate_footer {
    {-file_type:required}
} {
    Generate a file a footer.. only xql files have footers for now
    
    @param file_type What type of file is this xql, tcl, adp, vuh ?
} {
    if {[string equal $file_type "xql"] } {
	return "</queryset>"
    } else {
	return ""
    }
}


ad_proc -private ctrl_procs::prototype::parse_arg_values {
    {-values_list:required}
    {-key_sequence_name ""}
    {-file_type:required}
    {-proc_type:required "insert"}
} {
    Parse the arg values for tcl or xql
    
    @param values A list of sublists where each sublists contains the column name to insert and a default value,
                  the default value will be a string format with the following special key words : user_id, sysdate, or none.

    @param file_type Either for xql or tcl
    @param key_sequence_name The sequence name of the sequence to get the next value of.
    @param proc_type Either insert or update

    @returns a 2 elements list where the first element contains 
    the tcl procs args list and the tcl default values code in the body (ie: sysdate or user_id), if the file_type is tcl. OR if the 
    file_type is xql, the first element will be the value_names for the xql and the second item is the bind variables value list.

} {
    set item_1 ""
    set item_2 ""
    set tcl_indent "    "

    if {![string equal $proc_type "insert"]  &&  ![string equal $proc_type "update"]} {
	ad_return_complaint 1 "Proc type must be either insert or update. Your proc type was $proc_type"
	ad_script_abort
    }
    
    if { [string equal $file_type "xql"] } {

	if { [string equal $proc_type "insert"]} {
	    append item_1 "( "
	    append item_2 "values ( "
	} 
	
	set values_count [llength $values_list]
	foreach value_pair $values_list {
	    set value_name [lindex $value_pair 0]
	    set default_value [lindex $value_pair 1]
	    
	    if {$values_count != 1} {
		set end_line_val ",\n"
	    } else {
		set end_line_val "\n"
	    }
	    
	    if { [string equal $proc_type "insert"]} {
		append item_1 "${tcl_indent} $value_name $end_line_val"
		
		if {[string equal $default_value "sysdate"] || [regexp {to_date} $default_value match]} {
		    append item_2 "${tcl_indent} \$$value_name $end_line_val"
		} else {
		    append item_2 "${tcl_indent} :$value_name $end_line_val"
		}
		
	    } else {
		#for updates
		if {[regexp {to_date} $default_value match]} {
		    append item_1 "${tcl_indent} $value_name=\$$value_name $end_line_val"
		} else {
		    append item_1 "${tcl_indent} $value_name=:$value_name $end_line_val"
		}
	    }
	    
	    set values_count [expr $values_count -1]
	}
	
	if { [string equal $proc_type "insert"]} {
	    append item_1 ")"
	    append item_2 ")"
	} 

    } elseif {[string equal $file_type "tcl"]}  {

	foreach value_pair $values_list {
	    set value_name [lindex $value_pair 0]
	    set default_value [lindex $value_pair 1]
	    
	    if {[string equal $default_value "none"] ||  [regexp {to_date} $default_value match]} {
		append item_1 "${tcl_indent}{-${value_name}} \n"
	    } elseif { [string equal $default_value "sysdate" ] } {
		append item_1 "${tcl_indent}{-${value_name} \"sysdate\"} \n"
		#this format should correspond to the format given in to_date for the xql file_type of this proc
		#append item_2 "${tcl_indent}if {\[empty_string_p \$${value_name}\] } {\
		#	set $value_name to_date(\[clock format \[clock seconds\] -format \"%D %T\" \]},'mm/dd/yy HH24:MI:SS')\n" 
	    } elseif {[string equal $default_value "user_id"]} { 
		append item_1 "${tcl_indent}{-${value_name} \"\"} \n"
		append item_2 "${tcl_indent}if {\[empty_string_p \$${value_name}\] } {\
			set $value_name \[ad_conn user_id\]}\n" 
	    }  elseif {[string equal $default_value "sequence"]} {
		#for sequences
		append item_1 "${tcl_indent}{-${value_name} \"\"} \n"
		append item_2 "${tcl_indent}if {\[empty_string_p \$${value_name}\] } {\
			set $value_name \[db_nextval $key_sequence_name \]}\n" 
	    } else {
		append item_1 "${tcl_indent}{-${value_name} \"$default_value\"} \n"
	    }
	}

    } else {
	return ""
    }
    return [list $item_1 $item_2]
}


ad_proc -private ctrl_procs::prototype::backup {
    {-file_path:required}
} {
    Backup the old files
    
} {

    foreach type {.tcl .xql -oracle.xql} {
	#Make a backup of the old file by creating a writing into a backup director
	set new_file_path "$file_path${type}" 
	regexp {(.*)/(.*)} $file_path match directory file
	set file_list [glob -nocomplain -- $new_file_path]

	if {[llength $file_list] == 0} {
	    set file_exists_p 0
	} else {
	    set file_exists_p 1
	}

	if {$file_exists_p} {
	    set old_contents [template::util::read_file \
		    $new_file_path]
	    template::util::write_file "$directory/backup/$file${type}.bak"  $old_contents
	}
    }
}
